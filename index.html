<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>å¡”é˜²éŠæˆ²</title>
<style>
body { background:#222; color:white; text-align:center; font-family:sans-serif; }
canvas { border:2px solid white; cursor:pointer; }
button { margin:3px; }
</style>
</head>
<body>

<h2>ğŸ° å¡”é˜²éŠæˆ²</h2>
<p>
ä¸»å¡”è¡€é‡ï¼š<span id="hp">100</span>ï½œ
é‡‘éŒ¢ï¼š<span id="gold">500</span>ï½œ
æ³¢æ•¸ï¼š<span id="wave">1</span>ï½œ
<span id="wait"></span>
</p>

<div>
<button onclick="select('sword')">ğŸ—¡ï¸ åŠå£«</button>
<button onclick="select('archer')">ğŸ¹ å¼“ç®­æ‰‹</button>
<button onclick="select('mage')">ğŸª„ æ³•å¸«</button>
<button onclick="select('farm')">ğŸ’° è¾²å ´</button>
<button onclick="select('wall')">ğŸ›¡ï¸ å ¡å£˜</button>
</div>

<canvas id="game" width="640" height="360"></canvas>

<script>
const c = document.getElementById("game");
const ctx = c.getContext("2d");

let baseHp=100, gold=500, wave=1;
let selected=null, waiting=false, gameOver=false;
let selectedTower=null;

const towers=[], enemies=[];

const towerData={
  sword:{cost:100,dmg:5,range:60,cd:30,icon:"ğŸ—¡ï¸"},
  archer:{cost:250,dmg:10,range:110,cd:40,icon:"ğŸ¹"},
  mage:{cost:500,dmg:20,range:140,cd:60,icon:"ğŸª„"},
  farm:{cost:300,icon:"ğŸ’°"},
  wall:{cost:600,hp:100,range:18,icon:"ğŸ›¡ï¸"}
};

const enemyHpStage=[10,15,20,25,30];

const path=[
  {x:0,y:180},{x:140,y:180},{x:140,y:80},
  {x:340,y:80},{x:340,y:260},{x:540,y:260},{x:640,y:180}
];

// ğŸŒ³ èƒŒæ™¯æ¨¹
const trees=Array.from({length:6},()=>({
  x:Math.random()*600+20,
  y:Math.random()*320+20
}));

function select(t){ selected=t; }

function onPath(x,y){
  for(let i=0;i<path.length-1;i++){
    let a=path[i],b=path[i+1];
    if(Math.abs(x-a.x)<20 && y>Math.min(a.y,b.y)-20 && y<Math.max(a.y,b.y)+20) return true;
    if(Math.abs(y-a.y)<20 && x>Math.min(a.x,b.x)-20 && x<Math.max(a.x,b.x)+20) return true;
  }
  return false;
}

// é»æ“Š
c.onclick=e=>{
  if(gameOver) return;
  let x=e.offsetX,y=e.offsetY;
  selectedTower=null;

  for(let t of towers){
    if(Math.hypot(t.x-x,t.y-y)<20){
      selectedTower=t;
      return;
    }
  }

  if(!selected) return;
  let d=towerData[selected];
  if(gold<d.cost) return;

  if(selected!=="wall" && onPath(x,y)) return alert("ä¸èƒ½æ”¾åœ¨é“è·¯ä¸Š");

  for(let t of towers)
    if(Math.hypot(t.x-x,t.y-y)<40) return alert("è·é›¢å¤ªè¿‘");

  gold-=d.cost;
  towers.push({
    x,y,type:selected,
    dmg:d.dmg||0,range:d.range||0,
    cdMax:d.cd||0,cd:0,
    hp:d.hp||0,hitCd:0,
    cost:d.cost,icon:d.icon
  });
};

// å³éµåˆªé™¤
c.oncontextmenu=e=>{
  e.preventDefault();
  let x=e.offsetX,y=e.offsetY;
  for(let i=towers.length-1;i>=0;i--)
    if(Math.hypot(towers[i].x-x,towers[i].y-y)<20){
      towers.splice(i,1);
      selectedTower=null;
      return;
    }
};

// ç”Ÿæ€ªï¼ˆä¸€æ¬¡å…¨éƒ¨å‡ºï¼‰
function spawnWave(){
  let stage=Math.floor((wave-1)/5);
  let hp=enemyHpStage[stage];
  let count=10;
  for(let i=0;i<count;i++)
    enemies.push({hp,max:hp,p:0,i:i*35});
}
spawnWave();

function update(){
  if(gameOver) return;

  // è‰åœ°
  ctx.fillStyle="#9be38a";
  ctx.fillRect(0,0,640,360);

  // è·¯
  ctx.strokeStyle="#c2a060";
  ctx.lineWidth=30;
  ctx.beginPath();
  ctx.moveTo(path[0].x,path[0].y);
  path.forEach(p=>ctx.lineTo(p.x,p.y));
  ctx.stroke();

  // æ¨¹
  trees.forEach(t=>{
    ctx.fillStyle="brown";
    ctx.fillRect(t.x-3,t.y,6,10);
    ctx.beginPath();
    ctx.fillStyle="darkgreen";
    ctx.arc(t.x,t.y,12,0,Math.PI*2);
    ctx.fill();
  });

  // é¡¯ç¤ºç¯„åœ
  if(selectedTower && selectedTower.range){
    ctx.beginPath();
    ctx.strokeStyle="rgba(0,0,255,0.4)";
    ctx.arc(selectedTower.x,selectedTower.y,selectedTower.range,0,Math.PI*2);
    ctx.stroke();
  }

  // å¡”
  ctx.font="20px serif";
  towers.forEach(t=>{
    ctx.fillText(t.icon,t.x-10,t.y+8);
    ctx.font="12px sans-serif";
    ctx.fillText(`$${t.cost}`,t.x-14,t.y+22);
    ctx.font="20px serif";
  });

  // æ•µäºº
  ctx.font="18px serif";
  enemies.forEach(e=>{
    let a=path[e.p],b=path[e.p+1];
    let dx=b.x-a.x,dy=b.y-a.y,len=Math.hypot(dx,dy);
    e.i+=1;
    let t=e.i/len;
    if(t>=1){e.p++;e.i=0;}
    if(e.p>=path.length-1){baseHp-=5;e.hp=0;}
    e.x=a.x+dx*t; e.y=a.y+dy*t;

    ctx.fillText("ğŸ§Ÿ",e.x-10,e.y+8);
    ctx.fillStyle="red";
    ctx.fillText(e.hp,e.x-8,e.y-12);
    ctx.fillStyle="white";
  });

  // æ”»æ“Š
  towers.forEach(t=>{
    if(t.type==="wall"){
      if(t.hitCd>0) t.hitCd--;
      enemies.forEach(e=>{
        if(Math.hypot(t.x-e.x,t.y-e.y)<t.range && t.hitCd<=0){
          t.hp--; e.hp--;
          t.hitCd=15;
        }
      });
      return;
    }

    if(t.cd>0){t.cd--;return;}
    let target=null,min=999;
    enemies.forEach(e=>{
      let d=Math.hypot(t.x-e.x,t.y-e.y);
      if(d<t.range && d<min){min=d;target=e;}
    });
    if(target){
      target.hp-=t.dmg;
      t.cd=t.cdMax;
    }
  });

  // æ¸…é™¤
  for(let i=enemies.length-1;i>=0;i--)
    if(enemies[i].hp<=0){ enemies.splice(i,1); gold+=5; }
  for(let i=towers.length-1;i>=0;i--)
    if(towers[i].type==="wall" && towers[i].hp<=0)
      towers.splice(i,1);

  // æ³¢æ¬¡
  if(enemies.length===0 && !waiting){
    if(wave>=25){
      gameOver=true;
      setTimeout(()=>{
        if(confirm("ğŸ‰ ä½ è´äº†ï¼\nå†ä¾†ä¸€å ´ï¼Ÿ")) location.reload();
      },300);
      return;
    }
    waiting=true;
    let t=5;
    document.getElementById("wait").innerText=`ä¸‹ä¸€æ³¢ ${t}s`;
    let timer=setInterval(()=>{
      t--;
      document.getElementById("wait").innerText=`ä¸‹ä¸€æ³¢ ${t}s`;
      if(t<=0){
        clearInterval(timer);
        waiting=false;
        document.getElementById("wait").innerText="";
        towers.forEach(tt=>{ if(tt.type==="farm") gold+=150; });
        wave++; spawnWave();
      }
    },1000);
  }

  document.getElementById("hp").innerText=baseHp;
  document.getElementById("gold").innerText=gold;
  document.getElementById("wave").innerText=wave;
}

setInterval(update,30);
</script>
</body>
</html>
