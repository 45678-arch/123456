<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>å¡”é˜²éŠæˆ²</title>
<style>
body{background:#222;color:white;text-align:center;font-family:sans-serif}
canvas{border:2px solid white}
button{margin:3px;font-size:14px}
#info{margin-top:6px;height:24px}
</style>
</head>
<body>

<h2>ğŸ° å¡”é˜²éŠæˆ²</h2>
<p>
ä¸»å¡”è¡€é‡ï¼š<span id="hp">100</span>ï½œ
é‡‘éŒ¢ï¼š<span id="gold">500</span>ï½œ
æ³¢æ•¸ï¼š<span id="wave">1</span>ï½œ
è§’è‰²ï¼š<span id="count">0</span>/50
</p>

<div id="info"></div>

<div>
<button onclick="select('sword')">ğŸ—¡ï¸ åŠå£« ($100)</button>
<button onclick="select('archer')">ğŸ¹ å¼“ç®­æ‰‹ ($250)</button>
<button onclick="select('mage')">ğŸª„ æ³•å¸« ($500)</button>
<button onclick="select('farm')">ğŸ’° è¾²å ´ ($300)</button>
<button onclick="select('wall')">ğŸ›¡ï¸ å ¡å£˜ ($600)</button>
</div>

<canvas id="game" width="640" height="360"></canvas>

<script>
const c=document.getElementById("game");
const ctx=c.getContext("2d");
const info=document.getElementById("info");

let baseHp=100,gold=500,wave=1,gameOver=false;
let selected=null,selectedTower=null;

const MAX_TOWERS=50;
const towers=[],enemies=[];

const ENEMIES_PER_WAVE=5;
let spawnLeft=0,spawnDelay=0,spawnHp=10;

const towerData={
 sword:{cost:100,dmg:5,range:60,cd:30,icon:"ğŸ—¡ï¸"},
 archer:{cost:250,dmg:10,range:110,cd:40,icon:"ğŸ¹"},
 mage:{cost:500,dmg:20,range:140,cd:60,icon:"ğŸª„"},
 farm:{cost:300,icon:"ğŸ’°"},
 wall:{cost:600,hp:200,range:18,icon:"ğŸ›¡ï¸"}
};

const enemyHpStage=[10,15,20,25,30];

const path=[
 {x:0,y:180},{x:140,y:180},{x:140,y:80},
 {x:340,y:80},{x:340,y:260},{x:540,y:260},{x:640,y:180}
];

function select(t){selected=t;}

function onPath(x,y){
 for(let i=0;i<path.length-1;i++){
  let a=path[i],b=path[i+1];
  if(Math.abs(x-a.x)<20 && y>Math.min(a.y,b.y)-20 && y<Math.max(a.y,b.y)+20) return true;
  if(Math.abs(y-a.y)<20 && x>Math.min(a.x,b.x)-20 && x<Math.max(a.x,b.x)+20) return true;
 }
 return false;
}

/* å·¦éµ */
c.onclick=e=>{
 if(gameOver) return;
 let x=e.offsetX,y=e.offsetY;
 selectedTower=null;
 info.innerText="";

 for(let t of towers){
  if(Math.hypot(t.x-x,t.y-y)<20){
   selectedTower=t;
   if(t.range){
    info.innerText=`å‚·å®³ï¼š${t.dmg||0} ï½œ è·é›¢ï¼š${t.range}`;
   }
   return;
  }
 }

 if(!selected) return;
 if(towers.length>=MAX_TOWERS) return alert("è§’è‰²å·²é”ä¸Šé™");

 let d=towerData[selected];
 if(gold<d.cost) return;

 if(selected==="wall"&&!onPath(x,y)) return alert("å ¡å£˜åªèƒ½æ”¾åœ¨é“è·¯ä¸Š");
 if(selected!=="wall"&&onPath(x,y)) return alert("ä¸èƒ½æ”¾åœ¨é“è·¯ä¸Š");

 gold-=d.cost;
 towers.push({
  x,y,type:selected,
  dmg:d.dmg||0,
  range:d.range||0,
  cdMax:d.cd||0,
  cd:0,
  hp:d.hp||0,
  cost:d.cost,
  icon:d.icon
 });
};

/* å³éµåˆªé™¤ */
c.oncontextmenu=e=>{
 e.preventDefault();
 let x=e.offsetX,y=e.offsetY;
 for(let i=towers.length-1;i>=0;i--){
  if(Math.hypot(towers[i].x-x,towers[i].y-y)<20){
   gold+=Math.floor(towers[i].cost/2);
   if(selectedTower===towers[i]){selectedTower=null;info.innerText="";}
   towers.splice(i,1);
   return;
  }
 }
};

function startWave(){
 let stage=Math.floor((wave-1)/5);
 spawnHp=enemyHpStage[stage];
 spawnLeft=ENEMIES_PER_WAVE;
 spawnDelay=0;
}
startWave();

function spawnEnemy(){
 enemies.push({hp:spawnHp,maxHp:spawnHp,p:0,i:0});
 spawnLeft--; spawnDelay=30;
}

function update(){
 if(gameOver) return;

 /* åœ°åœ– */
 ctx.fillStyle="#9be38a";
 ctx.fillRect(0,0,640,360);
 ctx.strokeStyle="#c2a060";
 ctx.lineWidth=30;
 ctx.beginPath();
 ctx.moveTo(path[0].x,path[0].y);
 path.forEach(p=>ctx.lineTo(p.x,p.y));
 ctx.stroke();

 /* è§’è‰²æ•¸ */
 document.getElementById("count").innerText=towers.length;

 /* è·é›¢é¡¯ç¤º */
 if(selectedTower&&selectedTower.range){
  ctx.beginPath();
  ctx.strokeStyle="black";
  ctx.lineWidth=0.5;
  ctx.arc(selectedTower.x,selectedTower.y,selectedTower.range,0,Math.PI*2);
  ctx.stroke();
 }

 /* å¡” */
 ctx.font="20px serif";
 towers.forEach(t=>{
  ctx.fillText(t.icon,t.x-10,t.y+8);
  if(t.type==="wall"){
   ctx.font="12px sans-serif";
   ctx.fillText(t.hp,t.x-10,t.y-12);
   ctx.font="20px serif";
  }
 });

 /* ç”Ÿæ€ª */
 if(spawnLeft>0){
  if(spawnDelay<=0) spawnEnemy();
  else spawnDelay--;
 }

 /* æ•µäºº */
 enemies.forEach(e=>{
  let a=path[e.p],b=path[e.p+1];
  let dx=b.x-a.x,dy=b.y-a.y,len=Math.hypot(dx,dy);
  e.i+=1;
  let t=e.i/len;
  if(t>=1){e.p++;e.i=0;}
  if(e.p>=path.length-1){baseHp-=5;e.hp=0;}
  e.x=a.x+dx*t; e.y=a.y+dy*t;

  ctx.fillText("ğŸ§Ÿ",e.x-10,e.y+8);
  ctx.fillStyle="red";
  ctx.font="12px sans-serif";
  ctx.fillText(e.hp,e.x-8,e.y-12);
  ctx.font="20px serif";
 });

 /* æ”»æ“Š */
 towers.forEach(t=>{
  if(t.type==="wall"){
   enemies.forEach(e=>{
    if(Math.hypot(t.x-e.x,t.y-e.y)<t.range){
     let d=Math.min(t.hp,e.hp);
     t.hp-=d; e.hp-=d;
    }
   });
   return;
  }
  if(t.cd>0){t.cd--;return;}
  let target=null,min=999;
  enemies.forEach(e=>{
   let d=Math.hypot(t.x-e.x,t.y-e.y);
   if(d<t.range&&d<min){min=d;target=e;}
  });
  if(target){target.hp-=t.dmg;t.cd=t.cdMax;}
 });

 /* æ¸…é™¤ */
 for(let i=enemies.length-1;i>=0;i--){
  if(enemies[i].hp<=0){
   gold+=enemies[i].maxHp>=20?20:10;
   enemies.splice(i,1);
  }
 }

 /* ä¸‹ä¸€æ³¢ */
 if(enemies.length===0&&spawnLeft===0){
  towers.forEach(t=>{if(t.type==="farm") gold+=250;});
  wave++; if(wave>25){alert("ä½ è´äº†");location.reload();}
  startWave();
 }

 hp.innerText=baseHp;
 goldEl.innerText=gold;
 waveEl.innerText=wave;

 if(baseHp<=0){
  gameOver=true;
  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,640,360);
  ctx.fillStyle="white";
  ctx.font="40px sans-serif";
  ctx.textAlign="center";
  ctx.fillText("ä½ è¼¸äº†",320,180);
 }
}

const hp=document.getElementById("hp");
const goldEl=document.getElementById("gold");
const waveEl=document.getElementById("wave");

setInterval(update,30);
</script>
</body>
</html>
